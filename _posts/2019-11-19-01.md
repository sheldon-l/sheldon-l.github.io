---
layout: post
title: Shell Script - Basic
published_at: "2019-11-19"
updated_at: "2019-11-19"
author: Taners
tags: [Bash, Shell, Script]
status: published
---

## Basic Syntax of Bash

### Shebang

- New file named `HelloWorld.sh`

```shell
#!/bin/bash    # The sharp bang - "Shebang", followed by the interpreter for the commands
echo "Hello, world"
```

- Examples of Shebang:

```shell
#!/bin/csh
#!/bin/ksh
#!/bin/zsh
#!/usr/bin/python
```

- Run in Command Lines:

```bash
chmod 755 HelloWorld.sh
./HelloWorld.sh
```

### Variables

- `VARIABLE_NAME="Value"`

- `$VARIABLE_NAME` 

- or `${VARIABLE_NAME}` if need to immediately precede or follow the variable with additional data.

```bash
#!/bin/bash
MY_SHELL = "bash"
echo "I like the $MY_SHELL shell."
echo "I am ${MY_SHELL}ing on my keyboard."
```

- Assign the output of a command to a variable:

```bash
#!/bin/bash
SERVER_NAME=$(hostname)
echo "Running this script on ${SERVER_NAME}.
```

- Valid variable names can contain **letters, digits, and underscores**; can start with **letters, or underscores**

### Test and `if` statement

- Test for different conditions and act accordingly: `[CONDITION (is True)]`

```bash
[-d "FILE"]      # True if is a directory

[-e "FILE"]      # True if exists
[-f "FILE"]      # True if exists and is a regular file
[-s "FILE"]      # True if exists and is not empty

[-r "FILE"]      # True if is readable
[-w "FILE"]      # True if is writable
[-x "FILE"]      # True if is executable

[-z "STRING"]         # True if is empty
[-n "STRING"]         # True if is not empty
["STRING1" = "STRING1"]     
["STRING1" ！= "STRING1"]

["arg1" -eq "arg2"]     # =
["arg1" -ne "arg2"]     # !=
["arg1" -lt "arg2"]     # <
["arg1" -le "arg2"]     # <=
["arg1" -gt "arg2"]     # >
["arg1" -ge "arg2"]     # >=
```

- `if` statement:

```bash
if [CONDITION]
then
     commands...
elif [CONDITION]
then
     commands...
else #
     commands...
fi
```

```bash
#!/bin/bash
MY_SHELL="bash"

if ["$MY_SHELL"="bash"]  # it's a best practice to enclose variables in quotes 
                         # to prevent some unexpected side effects 
                         # when performing conditional tests
then 
     echo "You seem to like the bash shell."
elif ["$MY_SHELL"="csh"]
then
     echo "You seem to like the csh shell."
else #
     echo "You don't seem to like the bash or csh shells."
fi
```

### `for` statements

```bash
for VARIABLE in ITEM_1 ITEM_2 ITEM_n
do
     commands...
done
```

```bash
#!/bin/bash
COLORS="red green blue"

for COLOR in $COLORS
do
     echo "Color: $COLOR"
done
```

```bash
#!/bin/bash
PICTURES=$(ls *jpg)
DATE=$(date +%F)

for PICTURE in $PICTURES
do
     echo "Renaming '${PICTURE}' to '${DATE}-${PICTURE}'"
     mv ${PICTURE} ${DATE}-${PICTURE}
done
```

### Positional Prameters

- Variables that contain the contents of the command line: `$0` through `$9`

- `$0` refers to script istself, `$1` refers to the first parameter, and so on.

- Example: new file `archive_user.sh`

```bash
#!/bin/bash

echo "Executing script: $0"
echo "Archiving user: $1"

# Lock the account
passwd -l $1

# Create an archive of the home directory
tar cf /archives/${1}.tart.gz/home/${1}
```

```bash
./archive_user.sh user_name
```

- `$@`: from `$1` to the last one

```bash
#!/bin/bash

echo "Exacuting script: $0"

for USER in $@
do
     echo "Executing script: $0"
     echo "Archiving user: $USER"

     # Lock the account
     passwd -l $USER

     # Create an archive of the home directory
     tar cf /archives/${USER}.tart.gz /home/${USER}
done
```

```bash
./archive_user.sh user_name_1 user_name_2 user_name_n
```

### Getting User Input

- `read -p "PROMPT" VARIABLE_NAME`

```bash
#!/bin/bash

read -p "Enter a user name：" USER
echo "Archiving user: $USER"

passwd -l $USER
tar cf /achives/${USER}.tar.gz /home/${USER}
```

## Exit Statuses and Return Codes

### "`$?`"

- `$?` contains the return code of the previously executed command

```bash
HOST = "google.com"
ping -c 1 $HOST
RETURN_CODE = $?

if ["$RETURN_CODE" -ne "0"]
then
     echo "$HOST unreachable"
fi
```

### AND and OR (`&&` and `||`)

- `command_1 && command_2`:

  - do command_1, `if ["$?" -eq "0"]` then do command_2

```bash
#!/bin/bash

HOST = "google.com"
ping -c 1 $HOST && echo "$HOST reachable"
```

- `command_1 || command_2`:

  - do command_1, `if ["$?" -ne "0"]` then do command_2

```bash
#!/bin/bash

HOST = "google.com"
ping -c 1 $HOST || echo "$HOST unreachable"
```

### Semicolon “`；`”

- If chain commands together on a single line by separating with a semicolon "`;`", the semicolon doesn't  perform exit status checking, nomatter if the previous command faild or successed, the command following a semicolon will always get executed.

### The `exit` Command

- Control the exit status of shell script by using `exit $NUMBER` where the `NUMBER` is from `0` to `255`

```bash
HOST="google.com"
ping -c 1 $HOST
if ["$?" -ne "0"]
then
     echo "HOST unreachable."
     exit 1
fi
```

## Functions

```bash
#!/bin/bash

function fuction_name(){
     commands...
}
function_name

# OR
fuction_name(){
     commands...
}
function_name
```

## Fish Tutorial

[Fish Tutorial](https://fishshell.com/docs/current/tutorial.html)

```bash
apt install fish

# check if not added, add to /etc/shells
/bin/cat /etc/shells
apt echo /usr/bin/fish | sudo tee -a /etc/shells

# set as default
chsh /usr/bin/fish

# config as .bashrc
vim ~/.config/fish/config.fish

# config function
touch ~/.config/fish/functions/function_name.fish
vim ~/.config/fish/functions/function_name.fish

# $PATH
set PATH /usr/local/bin /usr/sbin $PATH
```
